#!/bin/bash
#
# Copyright (C) 2009 Red Hat, Inc.
# Copyright (c) 2000-2006 Silicon Graphics, Inc.  All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

dd()
{
   if [ "$HOSTOS" == "Linux" ]
   then
        command dd --help | grep noxfer > /dev/null 2>&1

        if [ "$?" -eq 0 ]
            then
                command dd status=noxfer $@
            else
                command dd $@
            fi
   else
        command dd $@
   fi
}

# poke_file 'test.img' 512 '\xff\xfe'
poke_file()
{
    printf "$3" | dd "of=$1" bs=1 "seek=$2" conv=notrunc &>/dev/null
}

# we need common.config
if [ "$iam" != "check" ]
then
    if ! . ./common.config
        then
        echo "$iam: failed to source common.config"
        exit 1
    fi
fi

# make sure we have a standard umask
umask 022

if [ "$IMGPROTO" = "file" ]; then
    TEST_IMG=$TEST_DIR/t.$IMGFMT
elif [ "$IMGPROTO" = "nbd" ]; then
    TEST_IMG_FILE=$TEST_DIR/t.$IMGFMT
    TEST_IMG="nbd:127.0.0.1:10810"
elif [ "$IMGPROTO" = "ssh" ]; then
    TEST_IMG_FILE=$TEST_DIR/t.$IMGFMT
    TEST_IMG="ssh://127.0.0.1$TEST_IMG_FILE"
elif [ "$IMGPROTO" = "nfs" ]; then
    TEST_DIR="nfs://127.0.0.1/$TEST_DIR"
    TEST_IMG=$TEST_DIR/t.$IMGFMT
elif [ "$IMGPROTO" = "archipelago" ]; then
    TEST_IMG="archipelago:at.$IMGFMT"
else
    TEST_IMG=$IMGPROTO:$TEST_DIR/t.$IMGFMT
fi

function valgrind_qemu_io()
{
    valgrind --log-file=/tmp/$$.valgrind --error-exitcode=99 $REAL_QEMU_IO "$@"
    if [ $? != 0 ]; then
        cat /tmp/$$.valgrind
    fi
    rm -f /tmp/$$.valgrind
}


_optstr_add()
{
    if [ -n "$1" ]; then
        echo "$1,$2"
    else
        echo "$2"
    fi
}

_set_default_imgopts()
{
    if [ "$IMGFMT" == "qcow2" ] && ! (echo "$IMGOPTS" | grep "compat=" > /dev/null); then
        IMGOPTS=$(_optstr_add "$IMGOPTS" "compat=1.1")
    fi
}

_use_sample_img()
{
    SAMPLE_IMG_FILE="${1%\.bz2}"
    TEST_IMG="$TEST_DIR/$SAMPLE_IMG_FILE"
    bzcat "$SAMPLE_IMG_DIR/$1" > "$TEST_IMG"
    if [ $? -ne 0 ]
    then
        echo "_use_sample_img error, cannot extract '$SAMPLE_IMG_DIR/$1'"
        exit 1
    fi
}

_make_test_img()
{
    # extra qemu-img options can be added by tests
    # at least one argument (the image size) needs to be added
    local extra_img_options=""
    local image_size=$*
    local optstr=""
    local img_name=""
    local use_backing=0
    local backing_file=""

    if [ -n "$TEST_IMG_FILE" ]; then
        img_name=$TEST_IMG_FILE
    else
        img_name=$TEST_IMG
    fi

    if [ -n "$IMGOPTS" ]; then
        optstr=$(_optstr_add "$optstr" "$IMGOPTS")
    fi

    if [ "$1" = "-b" ]; then
        use_backing=1
        backing_file=$2
        image_size=$3
    fi
    if [ \( "$IMGFMT" = "qcow2" -o "$IMGFMT" = "qed" \) -a -n "$CLUSTER_SIZE" ]; then
        optstr=$(_optstr_add "$optstr" "cluster_size=$CLUSTER_SIZE")
    fi

    if [ -n "$optstr" ]; then
        extra_img_options="-o $optstr $extra_img_options"
    fi

    # XXX(hch): have global image options?
    (
     if [ $use_backing = 1 ]; then
        $QEMU_IMG create -f $IMGFMT $extra_img_options -b "$backing_file" "$img_name" $image_size 2>&1
     else
        $QEMU_IMG create -f $IMGFMT $extra_img_options "$img_name" $image_size 2>&1
     fi
    ) | _filter_img_create

    # Start an NBD server on the image file, which is what we'll be talking to
    if [ $IMGPROTO = "nbd" ]; then
        eval "$QEMU_NBD -v -t -b 127.0.0.1 -p 10810 -f $IMGFMT  $TEST_IMG_FILE &"
        QEMU_NBD_PID=$!
        sleep 1 # FIXME: qemu-nbd needs to be listening before we continue
    fi
}

_rm_test_img()
{
    local img=$1
    if [ "$IMGFMT" = "vmdk" ]; then
        # Remove all the extents for vmdk
        "$QEMU_IMG" info "$img" 2>/dev/null | grep 'filename:' | cut -f 2 -d: \
            | xargs -I {} rm -f "{}"
    fi
    rm -f "$img"
}

_cleanup_test_img()
{
    case "$IMGPROTO" in

        nbd)
            if [ -n "$QEMU_NBD_PID" ]; then
                kill $QEMU_NBD_PID
            fi
            rm -f "$TEST_IMG_FILE"
            ;;
        file)
            _rm_test_img "$TEST_DIR/t.$IMGFMT"
            _rm_test_img "$TEST_DIR/t.$IMGFMT.orig"
            _rm_test_img "$TEST_DIR/t.$IMGFMT.base"
            if [ -n "$SAMPLE_IMG_FILE" ]
            then
                rm -f "$TEST_DIR/$SAMPLE_IMG_FILE"
            fi
            ;;

        rbd)
            rbd --no-progress rm "$TEST_DIR/t.$IMGFMT" > /dev/null
            ;;

        archipelago)
            vlmc remove "at.$IMGFMT" > /dev/null
            ;;

        sheepdog)
            collie vdi delete "$TEST_DIR/t.$IMGFMT"
            ;;

    esac
}

_check_test_img()
{
    $QEMU_IMG check "$@" -f $IMGFMT "$TEST_IMG" 2>&1 | _filter_testdir | \
        sed -e '/allocated.*fragmented.*compressed clusters/d' \
            -e 's/qemu-img: This image format does not support checks/No errors were found on the image./' \
            -e '/Image end offset: [0-9]\+/d'
}

_img_info()
{
    if [[ "$1" == "--format-specific" ]]; then
        local format_specific=1
        shift
    else
        local format_specific=0
    fi

    discard=0
    regex_json_spec_start='^ *"format-specific": \{'
    $QEMU_IMG info "$@" "$TEST_IMG" 2>&1 | \
        sed -e "s#$IMGPROTO:$TEST_DIR#TEST_DIR#g" \
            -e "s#$TEST_DIR#TEST_DIR#g" \
            -e "s#$IMGFMT#IMGFMT#g" \
            -e "/^disk size:/ D" \
            -e "/actual-size/ D" | \
        while IFS='' read line; do
            if [[ $format_specific == 1 ]]; then
                discard=0
            elif [[ $line == "Format specific information:" ]]; then
                discard=1
            elif [[ $line =~ $regex_json_spec_start ]]; then
                discard=2
                regex_json_spec_end="^${line%%[^ ]*}\\},? *$"
            fi
            if [[ $discard == 0 ]]; then
                echo "$line"
            elif [[ $discard == 1 && ! $line ]]; then
                echo
                discard=0
            elif [[ $discard == 2 && $line =~ $regex_json_spec_end ]]; then
                discard=0
            fi
        done
}

_get_pids_by_name()
{
    if [ $# -ne 1 ]
    then
        echo "Usage: _get_pids_by_name process-name" 1>&2
        exit 1
    fi

    # Algorithm ... all ps(1) variants have a time of the form MM:SS or
    # HH:MM:SS before the psargs field, use this as the search anchor.
    #
    # Matches with $1 (process-name) occur if the first psarg is $1
    # or ends in /$1 ... the matching uses sed's regular expressions,
    # so passing a regex into $1 will work.

    ps $PS_ALL_FLAGS \
    | sed -n \
        -e 's/$/ /' \
        -e 's/[         ][         ]*/ /g' \
        -e 's/^ //' \
        -e 's/^[^ ]* //' \
        -e "/[0-9]:[0-9][0-9]  *[^ ]*\/$1 /s/ .*//p" \
        -e "/[0-9]:[0-9][0-9]  *$1 /s/ .*//p"
}

# fqdn for localhost
#
_get_fqdn()
{
    host=`hostname`
    $NSLOOKUP_PROG $host | $AWK_PROG '{ if ($1 == "Name:") print $2 }'
}

# check if run as root
#
_need_to_be_root()
{
    id=`id | $SED_PROG -e 's/(.*//' -e 's/.*=//'`
    if [ "$id" -ne 0 ]
    then
        echo "Arrgh ... you need to be root (not uid=$id) to run this test"
        exit 1
    fi
}


# Do a command, log it to $seq.full, optionally test return status
# and die if command fails. If called with one argument _do executes the
# command, logs it, and returns its exit status. With two arguments _do
# first prints the message passed in the first argument, and then "done"
# or "fail" depending on the return status of the command passed in the
# second argument. If the command fails and the variable _do_die_on_error
# is set to "always" or the two argument form is used and _do_die_on_error
# is set to "message_only" _do will print an error message to
# $seq.out and exit.

_do()
{
    if [ $# -eq 1 ]; then
        _cmd=$1
    elif [ $# -eq 2 ]; then
        _note=$1
        _cmd=$2
        echo -n "$_note... "
    else
        echo "Usage: _do [note] cmd" 1>&2
        status=1; exit
    fi

    (eval "echo '---' \"$_cmd\"") >>"$OUTPUT_DIR/$seq.full"
    (eval "$_cmd") >$tmp._out 2>&1; ret=$?
    cat $tmp._out >>"$OUTPUT_DIR/$seq.full"
    if [ $# -eq 2 ]; then
        if [ $ret -eq 0 ]; then
            echo "done"
        else
            echo "fail"
        fi
    fi
    if [ $ret -ne 0  ] \
        && [ "$_do_die_on_error" = "always" \
            -o \( $# -eq 2 -a "$_do_die_on_error" = "message_only" \) ]
    then
        [ $# -ne 2 ] && echo
        eval "echo \"$_cmd\" failed \(returned $ret\): see $seq.full"
        status=1; exit
    fi

    return $ret
}

# bail out, setting up .notrun file
#
_notrun()
{
    echo "$*" >"$OUTPUT_DIR/$seq.notrun"
    echo "$seq not run: $*"
    status=0
    exit
}

# just plain bail out
#
_fail()
{
    echo "$*" | tee -a "$OUTPUT_DIR/$seq.full"
    echo "(see $seq.full for details)"
    status=1
    exit 1
}

# tests whether $IMGFMT is one of the supported image formats for a test
#
_supported_fmt()
{
    # "generic" is suitable for most image formats. For some formats it doesn't
    # work, however (most notably read-only formats), so they can opt out by
    # setting IMGFMT_GENERIC to false.
    for f; do
        if [ "$f" = "$IMGFMT" -o "$f" = "generic" -a "$IMGFMT_GENERIC" = "true" ]; then
            return
        fi
    done

    _notrun "not suitable for this image format: $IMGFMT"
}

# tests whether $IMGPROTO is one of the supported image protocols for a test
#
_supported_proto()
{
    for f; do
        if [ "$f" = "$IMGPROTO" -o "$f" = "generic" ]; then
            return
        fi
    done

    _notrun "not suitable for this image protocol: $IMGPROTO"
}

# tests whether the host OS is one of the supported OSes for a test
#
_supported_os()
{
    for h
    do
        if [ "$h" = "$HOSTOS" ]
        then
            return
        fi
    done

    _notrun "not suitable for this OS: $HOSTOS"
}

_supported_cache_modes()
{
    for mode; do
        if [ "$mode" = "$CACHEMODE" ]; then
            return
        fi
    done
    _notrun "not suitable for cache mode: $CACHEMODE"
}

_default_cache_mode()
{
    if $CACHEMODE_IS_DEFAULT; then
        CACHEMODE="$1"
        QEMU_IO="$QEMU_IO --cache $1"
        return
    fi
}

_unsupported_imgopts()
{
    for bad_opt
    do
        if echo "$IMGOPTS" | grep -q 2>/dev/null "$bad_opt"
        then
            _notrun "not suitable for image option: $bad_opt"
        fi
    done
}

# this test requires that a specified command (executable) exists
#
_require_command()
{
    eval c=\$$1
    [ -x "$c" ] || _notrun "$1 utility required, skipped this test"
}

_full_imgfmt_details()
{
    if [ -n "$IMGOPTS" ]; then
        echo "$IMGFMT ($IMGOPTS)"
    else
        echo "$IMGFMT"
    fi
}

_full_imgproto_details()
{
    echo "$IMGPROTO"
}

_full_platform_details()
{
    os=`uname -s`
    host=`hostname -s`
    kernel=`uname -r`
    platform=`uname -m`
    echo "$os/$platform $host $kernel"
}

_link_out_file()
{
   if [ -z "$1" ]; then
      echo Error must pass \$seq.
      exit
   fi
   rm -f $1
   if [ "`uname`" == "IRIX64" ] || [ "`uname`" == "IRIX" ]; then
      ln -s $1.irix $1
   elif [ "`uname`" == "Linux" ]; then
      ln -s $1.linux $1
   else
      echo Error test $seq does not run on the operating system: `uname`
      exit
   fi
}

_die()
{
        echo $@
        exit 1
}

# make sure this script returns success
true
